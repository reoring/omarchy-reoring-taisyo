#!/usr/bin/env bash
set -euo pipefail

STATE_FILE="${XDG_CACHE_HOME:-$HOME/.cache}/hypr-keyboard-clean-mode"
WAYBAR_KEYBOARD_CLEAN_SIGNAL="${WAYBAR_KEYBOARD_CLEAN_SIGNAL:-13}"

notify() {
  local message="$1"
  if command -v notify-send >/dev/null 2>&1; then
    notify-send "Keyboard cleaning" "$message" -t 1800 || true
  fi
}

refresh_waybar() {
  pkill -RTMIN+"$WAYBAR_KEYBOARD_CLEAN_SIGNAL" waybar >/dev/null 2>&1 || true
}

usage() {
  printf '%s\n' "Usage: $(basename "$0") [toggle|on|off]" >&2
}

read_mode() {
  if [[ -f "$STATE_FILE" ]]; then
    local mode
    mode="$(sed -n '1p' "$STATE_FILE" 2>/dev/null || true)"
    if [[ "$mode" == "on" ]]; then
      printf '%s' "on"
      return 0
    fi
  fi
  printf '%s' "off"
}

write_state_off() {
  mkdir -p "$(dirname "$STATE_FILE")"
  printf '%s\n' "off" >"$STATE_FILE"
}

write_state_on() {
  mkdir -p "$(dirname "$STATE_FILE")"
  {
    printf '%s\n' "on"
    if (( $# > 0 )); then
      printf '%s\n' "$@"
    fi
  } >"$STATE_FILE"
}

list_keyboards() {
  hyprctl devices -j 2>/dev/null \
    | jq -r '.keyboards // [] | .[] | .name // empty' \
    | sort -u
}

set_keyboard_enabled() {
  local keyboard="$1"
  local enabled="$2"

  local num_value="0"
  local bool_value="false"
  if [[ "$enabled" == "1" ]]; then
    num_value="1"
    bool_value="true"
  fi

  local -a keywords=(
    "device[$keyboard]:enabled"
    "device:$keyboard:enabled"
  )
  local output
  local status
  local keyword
  local value
  for keyword in "${keywords[@]}"; do
    for value in "$num_value" "$bool_value"; do
      output="$(hyprctl keyword "$keyword" "$value" 2>&1)" && status=0 || status=$?
      if (( status == 0 )) && [[ -z "$output" || "$output" == ok* ]]; then
        return 0
      fi
    done
  done
  return 1
}

enable_cleaning_mode() {
  local -a keyboards=()
  mapfile -t keyboards < <(list_keyboards)

  if (( ${#keyboards[@]} == 0 )); then
    notify "No keyboard devices found"
    return 1
  fi

  local -a succeeded=()
  local -a failed=()
  local keyboard
  for keyboard in "${keyboards[@]}"; do
    if set_keyboard_enabled "$keyboard" "0"; then
      succeeded+=("$keyboard")
    else
      failed+=("$keyboard")
    fi
  done

  if (( ${#succeeded[@]} == 0 )); then
    notify "Failed to disable keyboard devices"
    return 1
  fi

  write_state_on "${succeeded[@]}"
  if (( ${#failed[@]} > 0 )); then
    notify "ON (partial): ${#succeeded[@]} disabled, ${#failed[@]} failed"
  else
    notify "ON: ${#succeeded[@]} keyboard(s) disabled"
  fi
}

disable_cleaning_mode() {
  local -a targets=()
  if [[ -f "$STATE_FILE" ]]; then
    mapfile -t targets < <(tail -n +2 "$STATE_FILE" 2>/dev/null | sed '/^$/d')
  fi

  if (( ${#targets[@]} == 0 )); then
    mapfile -t targets < <(list_keyboards)
  fi

  if (( ${#targets[@]} == 0 )); then
    write_state_off
    notify "OFF: no keyboard devices found"
    return 0
  fi

  local ok_count=0
  local -a failed=()
  local keyboard
  for keyboard in "${targets[@]}"; do
    if set_keyboard_enabled "$keyboard" "1"; then
      ok_count=$((ok_count + 1))
    else
      failed+=("$keyboard")
    fi
  done

  if (( ${#failed[@]} == 0 )); then
    write_state_off
    notify "OFF: ${ok_count} keyboard(s) enabled"
    return 0
  fi

  write_state_on "${failed[@]}"
  notify "Partial restore: ${ok_count} enabled, ${#failed[@]} failed"
  return 1
}

action="${1:-toggle}"
case "$action" in
  toggle|on|off) ;;
  *)
    usage
    exit 2
    ;;
esac

if ! command -v hyprctl >/dev/null 2>&1; then
  notify "hyprctl not found"
  exit 1
fi
if ! command -v jq >/dev/null 2>&1; then
  notify "jq not found"
  exit 1
fi
if ! hyprctl devices -j >/dev/null 2>&1; then
  notify "Hyprland session not available"
  exit 1
fi

if [[ "$action" == "toggle" ]]; then
  if [[ "$(read_mode)" == "on" ]]; then
    action="off"
  else
    action="on"
  fi
fi

rc=0
if [[ "$action" == "on" ]]; then
  enable_cleaning_mode || rc=$?
else
  disable_cleaning_mode || rc=$?
fi

refresh_waybar
exit "$rc"
